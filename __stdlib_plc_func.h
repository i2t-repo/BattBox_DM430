/*------------------------------------------------------------------------------
Autogenerated declarations of standard library.
-------------------------------------------------------------------------------
Copyright (c) 2019 Danfoss

Warning: This header file is subject to change.
Do not use anything defined here directly in manually written C code.
-------------------------------------------------------------------------------*/

#ifndef _FILE___STDLIB_PLC_FUNC_H
#define _FILE___STDLIB_PLC_FUNC_H

#if defined(__GNUC__)
  #ifndef __TI_COMPILER_VERSION__
    #pragma GCC diagnostic ignored "-Wunused-function"
  #endif
#endif

#include <string.h> /* memcpy */
#include <math.h>
#include <stdio.h>
#include "__stdlib_plc_func_common.h"

STRING STD__STRING_LITERAL(const char* value, UINT cur_len);

static inline INT STD__ENABLE_ENO(BOOL* ENO);

void STD__COPY_STRING(STRING_OUT_REF dst, STRING src);

static inline LINT STD__GET_ARRAY_INDEX(DINT index, DINT min, DINT max);

static inline DINT STD__USINT_TO_DINT(BOOL* ENO, USINT IN1);

static inline USINT STD__ADD__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2);

static inline BOOL STD__GT__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2);

USINT STD__SUB__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2);

static inline PLC_RUNTIME_ERROR STD__SET_ERROR__LOOP_DEADLINE_PASSED();

static inline BOOL STD__EQ__BOOL_BOOL_2(BOOL* ENO, BOOL IN1, BOOL IN2);

static inline BOOL STD__NE__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2);

static inline BOOL STD__AND__BOOL_BOOL_2(BOOL* ENO, BOOL IN1, BOOL IN2);

static inline BOOL STD__OR__BOOL_BOOL_2(BOOL* ENO, BOOL IN1, BOOL IN2);

STRING STD__STRING_VAR_REF(void* str, UINT max_len);

static inline BOOL STD__EQ__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2);

static inline USINT STD__MUL__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2);

static inline void STD__USINT_TO_STRING(BOOL* ENO, USINT IN1, STRING_OUT_REF dst);

void STD__CONCAT__STRING_STRING_2(BOOL* ENO, STRING IN1, STRING IN2, STRING_OUT_REF result);

STRING STD__NEW_STRING_REF(UINT max_len, UINT cur_len, UINT* cur_len_ref, CHAR* value);

static inline INT STD__ASSIGN_ENO(BOOL* ENO, BOOL value);

static inline UINT STD__STRING_CUR_LEN(STRING IN);

DINT std__cut_STRING(CHAR* s, DINT len, DINT new_len);

LINT std__check_index(LINT index, DINT min, DINT max);

USINT STD__ADD__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2);

static inline BOOL STD__GT__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2);

static inline BOOL std__SUB_is_overflow_USINT(USINT IN1, USINT IN2);

static inline BOOL std__SUB_is_underflow_USINT(USINT IN1, USINT IN2);

static inline PLC_RUNTIME_ERROR STD__SET_ERROR__ARITHMETIC_OVERFLOW_UNDERFLOW();

static inline INT STD__DISABLE_ENO(BOOL* ENO);

static inline USINT std__handle_USINT_overflow(USINT IN);

static inline PLC_RUNTIME_ERROR std__set_error_bit(UINT bit);

static inline BOOL STD__EQ__BOOL_BOOL(BOOL* ENO, BOOL IN1, BOOL IN2);

static inline BOOL STD__AND__BOOL_BOOL(BOOL* ENO, BOOL IN1, BOOL IN2);

static inline BOOL STD__OR__BOOL_BOOL(BOOL* ENO, BOOL IN1, BOOL IN2);

static inline BOOL STD__EQ__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2);

USINT STD__MUL__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2);

void std__USINT_to_STRING(USINT value, STRING_OUT_REF dst);

UINT std__strcpy__STRING(STRING_OUT_REF dst, UINT dst_pos, STRING src, UINT src_pos, UINT len);

BOOL std__next_code_point_CHAR(USINT* s, DINT length, DINT* pi, DINT* result);

static inline PLC_RUNTIME_ERROR STD__SET_ERROR__INVALID_SUBSCRIPT();

static inline BOOL std__ADD_is_overflow_USINT(USINT IN1, USINT IN2);

static inline BOOL std__ADD_is_underflow_USINT(USINT IN1, USINT IN2);

static inline BOOL std__MUL_is_overflow_USINT(USINT IN1, USINT IN2);

static inline BOOL std__MUL_is_underflow_USINT(USINT IN1, USINT IN2);

static inline CHAR* std__sprintf_u(CHAR* dst, ULINT value);

void std__chars_to_str__STRING(CHAR* chars, UINT len, STRING_OUT_REF dst);

static inline USINT std__u8_count_trail_bytes(USINT leadByte);

static inline DINT std__u8_mask_lead_bytes(DINT leadByte, USINT countTrailBytes);

static inline BOOL std__u8_is_trail(USINT c);

CHAR* std__sprintf_Nu(CHAR* dst, ULINT value, INT digits);

static inline UINT std__min__UINT(UINT IN1, UINT IN2);

void std__reverse_chars(CHAR* str, DINT len);


static inline INT STD__ENABLE_ENO(BOOL* ENO) {
    return STD__ASSIGN_ENO(ENO, true);
}

static inline LINT STD__GET_ARRAY_INDEX(DINT index, DINT min, DINT max) {
    return std__check_index(index, min, max) - min;
}

static inline DINT STD__USINT_TO_DINT(BOOL* ENO, USINT IN1) {
    static DINT result;

    STD__ENABLE_ENO(ENO);
    result = (DINT)IN1;
    return result;
}

static inline USINT STD__ADD__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2) {
    return STD__ADD__USINT_USINT(ENO, IN1, IN2);
}

static inline BOOL STD__GT__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2) {
    return STD__GT__USINT_USINT(ENO, IN1, IN2);
}

static inline PLC_RUNTIME_ERROR STD__SET_ERROR__LOOP_DEADLINE_PASSED() {
    return std__set_error_bit(plc_error_bit__loop_deadline_passed);
}

static inline BOOL STD__EQ__BOOL_BOOL_2(BOOL* ENO, BOOL IN1, BOOL IN2) {
    return STD__EQ__BOOL_BOOL(ENO, IN1, IN2);
}

static inline BOOL STD__NE__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2) {
    STD__ENABLE_ENO(ENO);
    return IN1 != IN2;
}

static inline BOOL STD__AND__BOOL_BOOL_2(BOOL* ENO, BOOL IN1, BOOL IN2) {
    return STD__AND__BOOL_BOOL(ENO, IN1, IN2);
}

static inline BOOL STD__OR__BOOL_BOOL_2(BOOL* ENO, BOOL IN1, BOOL IN2) {
    return STD__OR__BOOL_BOOL(ENO, IN1, IN2);
}

static inline BOOL STD__EQ__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2) {
    return STD__EQ__USINT_USINT(ENO, IN1, IN2);
}

static inline USINT STD__MUL__USINT_USINT_2(BOOL* ENO, USINT IN1, USINT IN2) {
    return STD__MUL__USINT_USINT(ENO, IN1, IN2);
}

static inline void STD__USINT_TO_STRING(BOOL* ENO, USINT IN1, STRING_OUT_REF dst) {

    STD__ENABLE_ENO(ENO);
    std__USINT_to_STRING(IN1, dst);
}

static inline INT STD__ASSIGN_ENO(BOOL* ENO, BOOL value) {
    if (ENO != NULL) {
        (*ENO) = value;
    }
    return 0;
}

static inline UINT STD__STRING_CUR_LEN(STRING IN) {
    return IN.cur_len_ref != NULL ? *IN.cur_len_ref : IN.cur_len_val;
}

static inline BOOL STD__GT__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2) {
    STD__ENABLE_ENO(ENO);
    return IN1 > IN2;
}

static inline BOOL std__SUB_is_overflow_USINT(USINT IN1, USINT IN2) {
    return false;
}

static inline BOOL std__SUB_is_underflow_USINT(USINT IN1, USINT IN2) {
    return IN2 > IN1;
}

static inline PLC_RUNTIME_ERROR STD__SET_ERROR__ARITHMETIC_OVERFLOW_UNDERFLOW() {
    return std__set_error_bit(plc_error_bit__arithmetic_overflow_underflow);
}

static inline INT STD__DISABLE_ENO(BOOL* ENO) {
    return STD__ASSIGN_ENO(ENO, false);
}

static inline USINT std__handle_USINT_overflow(USINT IN) {
#if CHAR_BIT == 8
    return IN;
#elif CHAR_BIT == 16
    return IN & 0x00FF;
#else
    #error "Unsupported CHAR_BIT value!"
#endif
}

static inline PLC_RUNTIME_ERROR std__set_error_bit(UINT bit) {
    __RUNTIME_ERROR_FLAGS |= ((UINT)1 << (bit));
    return __RUNTIME_ERROR_FLAGS;
}

static inline BOOL STD__EQ__BOOL_BOOL(BOOL* ENO, BOOL IN1, BOOL IN2) {
    STD__ENABLE_ENO(ENO);
    return IN1 == IN2;
}

static inline BOOL STD__AND__BOOL_BOOL(BOOL* ENO, BOOL IN1, BOOL IN2) {
    STD__ENABLE_ENO(ENO);
    return IN1 & IN2;
}

static inline BOOL STD__OR__BOOL_BOOL(BOOL* ENO, BOOL IN1, BOOL IN2) {
    STD__ENABLE_ENO(ENO);
    return IN1 | IN2;
}

static inline BOOL STD__EQ__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2) {
    STD__ENABLE_ENO(ENO);
    return IN1 == IN2;
}

static inline PLC_RUNTIME_ERROR STD__SET_ERROR__INVALID_SUBSCRIPT() {
    return std__set_error_bit(plc_error_bit__invalid_subscript);
}

static inline BOOL std__ADD_is_overflow_USINT(USINT IN1, USINT IN2) {
    return PLC_USINT_MAX - IN2 < IN1;
}

static inline BOOL std__ADD_is_underflow_USINT(USINT IN1, USINT IN2) {
    return false;
}

static inline BOOL std__MUL_is_overflow_USINT(USINT IN1, USINT IN2) {
    return ((ULINT)IN1) * ((ULINT)IN2) > PLC_USINT_MAX;
}

static inline BOOL std__MUL_is_underflow_USINT(USINT IN1, USINT IN2) {
    return false;
}

static inline CHAR* std__sprintf_u(CHAR* dst, ULINT value) {
    return std__sprintf_Nu(dst, value, 1);
}

static inline USINT std__u8_count_trail_bytes(USINT leadByte) {
    return leadByte < 0xf0
                ? (leadByte >= 0xc0) + (leadByte >= 0xe0)
                : leadByte < 0xfe
                    ? 3 + (leadByte >= 0xf8) + (leadByte >= 0xfc)
                    : 0;
}

static inline DINT std__u8_mask_lead_bytes(DINT leadByte, USINT countTrailBytes) {
    return leadByte & ((1 << (6 - countTrailBytes)) - 1);
}

static inline BOOL std__u8_is_trail(USINT c) {
    return (c & 0xc0) == 0x80;
}

static inline UINT std__min__UINT(UINT IN1, UINT IN2) {
    return IN1 < IN2 ? IN1 : IN2;
}



#endif /* _FILE___STDLIB_PLC_FUNC_H */

