/*------------------------------------------------------------------------------
Autogenerated definitions of standard library.
-------------------------------------------------------------------------------
Copyright (c) 2019 Danfoss
-------------------------------------------------------------------------------*/

#include "__stdlib_plc_func.h"

static CHAR std__var_conv_tmp_chars[255];


STRING STD__STRING_LITERAL(const char* value, UINT cur_len) {
	return STD__NEW_STRING_REF(0, cur_len, NULL, (CHAR*)value);
}

void STD__COPY_STRING(STRING_OUT_REF dst, STRING src) {
    static UINT len;

    len = STD__STRING_CUR_LEN(src);

    if (len > dst.max_len) {
        len = std__cut_STRING(src.value, len, dst.max_len);
    }
    memcpy(dst.value, src.value, sizeof(CHAR) * len);
    *dst.cur_len_ref = len;
}

USINT STD__SUB__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2) {
    STD__ENABLE_ENO(ENO);
    if (std__SUB_is_overflow_USINT(IN1, IN2) || std__SUB_is_underflow_USINT(IN1, IN2)) {
        STD__SET_ERROR__ARITHMETIC_OVERFLOW_UNDERFLOW();
        STD__DISABLE_ENO(ENO);
        return std__handle_USINT_overflow(IN1 - IN2);
    }
    return IN1 - IN2;
}

STRING STD__STRING_VAR_REF(void* str, UINT max_len) {
    static PLC_ANY_STRING* any_str;

    any_str = (PLC_ANY_STRING*)str;
    
    return STD__NEW_STRING_REF(max_len, 0, &(any_str->cur_len), &(any_str->value[0]));
}

void STD__CONCAT__STRING_STRING_2(BOOL* ENO, STRING IN1, STRING IN2, STRING_OUT_REF result) {
    static UINT res_pos;

    res_pos = 0;

    STD__ENABLE_ENO(ENO);
    res_pos = std__strcpy__STRING(result, res_pos, IN1, 0, STD__STRING_CUR_LEN(IN1));
    res_pos = std__strcpy__STRING(result, res_pos, IN2, 0, STD__STRING_CUR_LEN(IN2));
}

STRING STD__NEW_STRING_REF(UINT max_len, UINT cur_len, UINT* cur_len_ref, CHAR* value) {
    static PLC_STRING_REF res;

    res.max_len = max_len;
    res.cur_len_val = cur_len;
    res.cur_len_ref = cur_len_ref;
    res.value = value;
    return res;
}

DINT std__cut_STRING(CHAR* s, DINT len, DINT new_len) {
    static BOOL good;
    static DINT i;
    static DINT j;
    static DINT c;

    good = false;
    i = 0;

    for (j = 1; j <= 4 && j <= new_len; j++) {
        i = new_len - j;
        good = std__next_code_point_CHAR(s, len, &i, &c);
        if (good) break;
    }
    return !good || i <= new_len ? new_len : new_len - j;
}

LINT std__check_index(LINT index, DINT min, DINT max) {
    if (index < min) {
        STD__SET_ERROR__INVALID_SUBSCRIPT();
        return min;
    }
    if (index > max) {
        STD__SET_ERROR__INVALID_SUBSCRIPT();
        return max;
    }
    return index;
}

USINT STD__ADD__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2) {
    STD__ENABLE_ENO(ENO);
    if (std__ADD_is_overflow_USINT(IN1, IN2) || std__ADD_is_underflow_USINT(IN1, IN2)) {
        STD__SET_ERROR__ARITHMETIC_OVERFLOW_UNDERFLOW();
        STD__DISABLE_ENO(ENO);
        return std__handle_USINT_overflow(IN1 + IN2);
    }
    return IN1 + IN2;
}

USINT STD__MUL__USINT_USINT(BOOL* ENO, USINT IN1, USINT IN2) {
    STD__ENABLE_ENO(ENO);
    if (std__MUL_is_overflow_USINT(IN1, IN2) || std__MUL_is_underflow_USINT(IN1, IN2)) {
        STD__SET_ERROR__ARITHMETIC_OVERFLOW_UNDERFLOW();
        STD__DISABLE_ENO(ENO);
        return std__handle_USINT_overflow(IN1 * IN2);
    }
    return IN1 * IN2;
}

void std__USINT_to_STRING(USINT value, STRING_OUT_REF dst) {
    static UINT len;
    
    CHAR* tmpDst = std__var_conv_tmp_chars;

    len = std__sprintf_u(tmpDst, value) - tmpDst;
    std__chars_to_str__STRING(tmpDst, len, dst);
}

UINT std__strcpy__STRING(STRING_OUT_REF dst, UINT dst_pos, STRING src, UINT src_pos, UINT len) {
    static UINT left_len;

    if (dst_pos > dst.max_len) {
        dst_pos = dst.max_len;
    }
    left_len = dst.max_len - dst_pos;
    if (len > left_len) {
        len = left_len;
    }
    if (len > 0) {
        memcpy(&dst.value[dst_pos], &src.value[src_pos], sizeof(CHAR) * len);
    }
    *dst.cur_len_ref = dst_pos + len;
    return *dst.cur_len_ref;
}

BOOL std__next_code_point_CHAR(USINT* s, DINT length, DINT* pi, DINT* result) {
    static const DINT utf8_minLegal[4] = { 0, 0x80, 0x800, 0x10000 };

    static DINT i;
    static BOOL error;
    static DINT c;
    static USINT count;
    static USINT trail;
    static USINT tmp1;
    static USINT tmp2;

    error = false;
    i = *pi;
    c = s[i++];

    if (c >= 0x80) {
        if (0xe0 < c && c <= 0xec && i + 1 < length && (tmp1 = s[i] - 0x80) <= 0x3f && (tmp2 = s[i + 1] - 0x80) <= 0x3f) {
            c = (UINT)((c << 12) | (tmp1 << 6) | tmp2);
            i += 2;
        } else if (0xc2 <= c && c < 0xe0 && i < length && (tmp1 = s[i] - 0x80) <= 0x3f) {
            c = ((c & 0x1f) << 6) | tmp1;
            i++;
        } else {
            error = true;
            count = std__u8_count_trail_bytes(c);
            if (i + count <= length) {
                c = std__u8_mask_lead_bytes(c, count);
                switch (count) {
                    case 0:
                    case 5:
                    case 4:
                        break;
                    case 3:
                        trail = s[i++] - 0x80;
                        c = (c << 6) | trail;
                        if (c >= 0x110 || trail > 0x3f) { break; }
                    case 2:
                        trail = s[i++] - 0x80;
                        c = (c << 6) | trail;
                        if ((c & 0xffe0) == 0x360 || trail > 0x3f) { break; }
                    case 1:
                        trail = s[i++] - 0x80;
                        c = (c << 6) | trail;
                        if (trail > 0x3f) { break; }
                        if (c >= utf8_minLegal[count]) {
                            error = false;
                        }
                }
            } else {
                count = length - i;
            }
            if (error) {
                while (count > 0 && std__u8_is_trail(s[i])) {
                    i++;
                    count--;
                }
                c = '?';
            }
        }
    }

    *pi = i;
    *result = c;
    return !error;
}

void std__chars_to_str__STRING(CHAR* chars, UINT len, STRING_OUT_REF dst) {
    len = std__min__UINT(len, dst.max_len);
    memcpy(dst.value, chars, sizeof(CHAR) * len);
    *dst.cur_len_ref = len;
}

CHAR* std__sprintf_Nu(CHAR* dst, ULINT value, INT digits) {
    static CHAR* new_dst;

    new_dst = dst;

    do {
        *(new_dst++) = '0' + (value % 10);
        value /= 10;
    } while (value > 0);
    while (new_dst - dst < digits) *(new_dst++) = '0';
    std__reverse_chars(dst, new_dst - dst);
    return new_dst;
}

void std__reverse_chars(CHAR* str, DINT len) {
    static DINT i, j;
    static CHAR c;

    for (i = 0, j = len - 1; i < j; i++, j--) {
        c = str[i];
        str[i] = str[j];
        str[j] = c;
    }
}



